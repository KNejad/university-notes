1:
  a:
    Atomicity: Each transaction should be an atomic, indivisible action
    Consistency: Each transaction should transform the system from one consistent state to another
    Isolation: Other transactions should not be able to see the intermediate steps of another action
    Durability: Once an action is committed it should persist on the system even in case of an unexpected system failure
  b:
    i: Two-version locking allows for multiple read locks to exist whilst a write lock exists. It works by creating a duplicate of an object which is used to written to. A commit lock is required (which is only given when there are no other read or write locks active) in order to write a new version of the object
    ii:
      No lock exists: [ read lock, write lock, commit lock ]
      Read lock exists: [ read lock, write lock, wait for commit lock ]
      Write lock exists: [ read lock, wait for write lock, no commit lock ]
      Commit lock exists: [ wait for read lock, wait for write lock, wait for commit lock]
  c:
    i: In 2PC an organiser server asks the participants if they can commit to a certain transaction. The servers will then have nested transactions which they need to check if they can commit to. If the nested transactions can commit (or if the server decides those transactions are not important) it will reply to the organiser that it can commit. At which point if all participants have committed, the organiser can tell them to go ahead with the transactions. The organiser can also abort the transaction and all participants will abort and notify the sub-transactions to also abort
    ii: If both the organiser and a participant crash at the same time the living participants must wait for the participant to recover. This is because the organiser may have notified the dead participant to go ahead with the transaction. So when it revives it will do so. The remaining participants thus can't abort safely and keep the system consistent as required by the ACID principles
  d: We must calculate how likely each server is to fail and what level of fault tolerance we are content with. For example if each server has a 20% failure rate for a given day and we want 99% up time, we would need 3 servers since 0.2 * 0.2 * 0.2 = 0.008 which is less than 1% down time
2:
  a:
    i: Java provides a way to enforce mutual exclusion in any part of a Java program through the use of a Monitor
    ii: The `synchronized` keyword can be used in order to prevent multiple accesses of an object concurrently. This can be applied to a method in Java before the method definition
  b:
    i: Priority allows developers to set priority levels to threads so the Java VM can queue threads accordingly
    ii: When a thread calls yield it will give up the processor and allow other threads to continue
    iii: when a thread calls join on another thread, it will not continue execution until the other thread completed
  c:
    i: The addItem() and getItem() methods need to be regarded as critical sections since they alter an object which is not thread safe. We can enforce mutual exclusion here by adding the `synchronized` keyword to each method
    ii: We must create a `BufferInterface` interface which `BufferImpl` must implement. Additionally, `BufferInterface` must implement `Serializable` so that it can serialised and transmitted between the client and server
  d:
    i: The RMI activation service starts instances up when requested by remote objects and handles reviving them in case of crashes or unintended destruction of the objects
    ii: It allows systems to launch instances in multiple servers and allows for recovery if anything fails
  e: It allows access to private variables and methods of the outer class as well as bypassing constructors
