Reduction: Converting one expression into another
Bound variable: Variables which first appear on the left hand side of a lambda term (before the dot)
Free variable: Variables which first appear on the right hand side of a lambda term
α-equivalence: Multiple lambda expressions are α-equivalent when they always produce the same result with the same binding variables
≡: For an expression "x ≡ y" it denotes that x is identical to y
β-reduction: When applying a lambda function to an argument, we can do a single reduction on it by replacing all occurrences of the variable on the right hand side with the argument. For example, applying "y" to "λx.xyz" would result in "yyz"
Normal form: A term is in its normal form if it cannot be reduced any further
Redex: Short for reducible expression, refers to subterms that can be reduced by one of the reduction rules
β-normal form: A lambda-term with no sub-terms that can be reduced
Reduction strategies:
  call-by-name: Outermost redexes are always reduced first
  call-by-value: Only reduce when the right-hand-side is already a term that cannot be reduced further, only outermost reductions are done
Typed lambda calculus:
  Description: Introduces types to lambda calculus
  Context: Set variables to certain types (e.g. "Γ |- M : τ" sets the term M to type τ in context Γ)
  Well typed: A term is well typed within a context if it is derivable from that context
  Type safety:
    Progress: A well-typed term will not get stuck
    Preservation: If a well-typed term takes a step of evaluation, then the resulting term is also well typed
  Strongly normalizing: A term which can be converted to its normal form in a finite number of steps
