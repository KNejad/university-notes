{
	"_title": "Practical 10 â€“ Functional Programming in Haskell",
	"_date": "Mon Apr 24 16:51:23 BST 2017",
	"1": {
		"Task": {
			"Description": "Write a Haskell program (in your file) to compute the function f(x,y,z)=x/y+(z/2)",
			"a": "Hint: standard types include Int and Float",
			"b": "Load the file into ghci or equivalent, and try it with various input values",
			"c": "Specify the type of your function"
		},
		"Solution": {"_file": "practical-10/1_sol.hs"}
	},
	"2": {
		"Task": "Write a Haskell program to compute the function g(x,y,z) = [x/z if z=2] [y*y/x otherwise] Again, try it out and specify its type",
		"Solution": {"_file": "practical-10/2_sol.hs"}
	},
	"3": {
		"Task": {
			"Description": "Write a Haskell program to compute the function h(x,y)= [0 if x=y] [1+h(x-1,y) otherwise]",
			"a": "What is this function computing?",
			"b": "Specify the type of the function", 
			"c": "Try your solution with input parameters 3 and 2. What happens and why? Can you solve the problem?"
		},
		"Solution": ""
	},
	"4": {
		"Task": "The in-built higher-order function map has the type definition map :: (a->b)->[a]->[b] Write a function, i, that uses map to compute a list containing the cube of a list of numbers. For example, if the parameter to the function was [1,2,3,4] the evaluation of the function should be [1,8,27,64].5. List comprehension is expressed as follows: [f x | x <- xs, g x] This means, create the list containing the results of applying the function f to x such that x comes from the list xs and the function g x returns True. Think of it as a combination of map (in this case f x) and filter (in this case g x). Write a function (j) that tests whether an integer is a multiple of 3. Then write a function (k) to compute a list containing (in increasing order) all numbers that are the cube of numbers that are multiples of 3 less than some number. The type of your functions should be j :: Int -> Bool k :: Int -> [Int] Hint: you can define the list of all positive integers from 1 to x as [1..x].",
		"Solution": "" 
	},
	"6": {
		"Task": "A recursive function is defined as follows: l :: [Int] -> [[Int]] l [] = [] l (x:xs) = [x,x-2..0]:(l xs) How can you rewrite this function using list comprehension? This would result in a single line of code. You decide that you want to return the result in a single list rather than a list of lists; i.e. you want to concatenate the results together. Modify your program to do this. ",
		"Solution": "" 
	}
}
